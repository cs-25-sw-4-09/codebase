//! Module for the lexer and parser for `Cfg`
//! WARNING: this file has been generated by
//! Hime Parser Generator 4.4.0

use hime_redist::ast::{AstImpl, AstNode};
use hime_redist::errors::ParseErrors;
use hime_redist::lexers::automaton::Automaton;
use hime_redist::lexers::impls::ContextFreeLexer;
use hime_redist::lexers::Lexer;
use hime_redist::parsers::lrk::LRkAutomaton;
use hime_redist::parsers::lrk::LRkParser;
use hime_redist::parsers::Parser;
use hime_redist::result::{ParseResult, ParseResultAst};
use hime_redist::symbols::SemanticBody;
use hime_redist::symbols::SemanticElementTrait;
use hime_redist::symbols::Symbol;
use hime_redist::text::Text;
use hime_redist::tokens::TokenRepository;

/// Static resource for the serialized lexer automaton
static LEXER_AUTOMATON: &[u8] = include_bytes!("cfg_lexer.bin");

/// The unique identifier for terminal `SEPARATOR`
pub const ID_TERMINAL_SEPARATOR: u32 = 0x0006;
/// The unique identifier for terminal `INTEGER`
pub const ID_TERMINAL_INTEGER: u32 = 0x0008;
/// The unique identifier for terminal `FLOAT`
pub const ID_TERMINAL_FLOAT: u32 = 0x0009;
/// The unique identifier for terminal `IDENTIFIER`
pub const ID_TERMINAL_IDENTIFIER: u32 = 0x000B;
/// The unique identifier for terminal `STRING`
pub const ID_TERMINAL_STRING: u32 = 0x000C;
/// The unique identifier for terminal `BOOLEAN`
pub const ID_TERMINAL_BOOLEAN: u32 = 0x000D;

/// The unique identifier for the default context
pub const CONTEXT_DEFAULT: u16 = 0;

/// The collection of terminals matched by this lexer
/// The terminals are in an order consistent with the automaton,
/// so that terminal indices in the automaton can be used to retrieve the terminals in this table
pub const TERMINALS: &[Symbol] = &[
    Symbol {
        id: 0x0001,
        name: "Îµ"
    },
    Symbol {
        id: 0x0002,
        name: "$"
    },
    Symbol {
        id: 0x0006,
        name: "SEPARATOR"
    },
    Symbol {
        id: 0x0008,
        name: "INTEGER"
    },
    Symbol {
        id: 0x0009,
        name: "FLOAT"
    },
    Symbol {
        id: 0x000B,
        name: "IDENTIFIER"
    },
    Symbol {
        id: 0x000C,
        name: "STRING"
    },
    Symbol {
        id: 0x000D,
        name: "BOOLEAN"
    },
    Symbol {
        id: 0x003D,
        name: "begin"
    },
    Symbol {
        id: 0x003F,
        name: "import"
    },
    Symbol {
        id: 0x0040,
        name: ";"
    },
    Symbol {
        id: 0x0041,
        name: ":"
    },
    Symbol {
        id: 0x0042,
        name: "="
    },
    Symbol {
        id: 0x0044,
        name: "fork"
    },
    Symbol {
        id: 0x0045,
        name: "{"
    },
    Symbol {
        id: 0x0046,
        name: "}"
    },
    Symbol {
        id: 0x0047,
        name: "for"
    },
    Symbol {
        id: 0x0048,
        name: "in"
    },
    Symbol {
        id: 0x0049,
        name: "draw"
    },
    Symbol {
        id: 0x004A,
        name: "at"
    },
    Symbol {
        id: 0x004B,
        name: "return"
    },
    Symbol {
        id: 0x004C,
        name: "("
    },
    Symbol {
        id: 0x004D,
        name: ")"
    },
    Symbol {
        id: 0x004E,
        name: "->"
    },
    Symbol {
        id: 0x0050,
        name: "otherwise"
    },
    Symbol {
        id: 0x0051,
        name: "||"
    },
    Symbol {
        id: 0x0052,
        name: "&&"
    },
    Symbol {
        id: 0x0053,
        name: "=="
    },
    Symbol {
        id: 0x0054,
        name: "<"
    },
    Symbol {
        id: 0x0055,
        name: ">"
    },
    Symbol {
        id: 0x0056,
        name: ">="
    },
    Symbol {
        id: 0x0057,
        name: "<="
    },
    Symbol {
        id: 0x0058,
        name: "!="
    },
    Symbol {
        id: 0x0059,
        name: "+"
    },
    Symbol {
        id: 0x005A,
        name: "-"
    },
    Symbol {
        id: 0x005B,
        name: "%"
    },
    Symbol {
        id: 0x005C,
        name: "*"
    },
    Symbol {
        id: 0x005D,
        name: "/"
    },
    Symbol {
        id: 0x005E,
        name: "!"
    },
    Symbol {
        id: 0x005F,
        name: ","
    },
    Symbol {
        id: 0x0060,
        name: "."
    },
    Symbol {
        id: 0x0061,
        name: ".."
    },
    Symbol {
        id: 0x0062,
        name: "..="
    },
    Symbol {
        id: 0x0063,
        name: "--"
    },
    Symbol {
        id: 0x0064,
        name: "~~"
    },
    Symbol {
        id: 0x0066,
        name: "--*"
    },
    Symbol {
        id: 0x0067,
        name: "~~*"
    },
    Symbol {
        id: 0x0069,
        name: "(|"
    },
    Symbol {
        id: 0x006A,
        name: "|)"
    },
    Symbol {
        id: 0x006C,
        name: "["
    },
    Symbol {
        id: 0x006D,
        name: "]"
    },
    Symbol {
        id: 0x0070,
        name: "[]"
    },
    Symbol {
        id: 0x0071,
        name: "left"
    },
    Symbol {
        id: 0x0072,
        name: "right"
    },
    Symbol {
        id: 0x0073,
        name: "top"
    },
    Symbol {
        id: 0x0074,
        name: "bottom"
    },
    Symbol {
        id: 0x0075,
        name: "ontop"
    },
    Symbol {
        id: 0x0076,
        name: "on"
    },
    Symbol {
        id: 0x0077,
        name: "place"
    },
    Symbol {
        id: 0x0078,
        name: "scale"
    },
    Symbol {
        id: 0x0079,
        name: "by"
    },
    Symbol {
        id: 0x007A,
        name: "rotate"
    },
    Symbol {
        id: 0x007C,
        name: "int"
    },
    Symbol {
        id: 0x007D,
        name: "float"
    },
    Symbol {
        id: 0x007E,
        name: "point"
    },
    Symbol {
        id: 0x007F,
        name: "color"
    },
    Symbol {
        id: 0x0080,
        name: "shape"
    },
    Symbol {
        id: 0x0081,
        name: "path"
    },
    Symbol {
        id: 0x0082,
        name: "polygon"
    },
    Symbol {
        id: 0x0083,
        name: "bool"
    }
];

/// Creates a new lexer
fn new_lexer<'a: 'b, 'b, 'c>(
    repository: TokenRepository<'a, 'b, 'c>,
    errors: &'c mut ParseErrors<'a>
) -> Lexer<'a, 'b, 'c> {
    let automaton = Automaton::new(LEXER_AUTOMATON);
    Lexer::ContextFree(ContextFreeLexer::new(repository, errors, automaton, 0x0006))
}

/// Static resource for the serialized parser automaton
static PARSER_AUTOMATON: &[u8] = include_bytes!("cfg_parser.bin");

/// The unique identifier for variable `program`
pub const ID_VARIABLE_PROGRAM: u32 = 0x000E;
/// The unique identifier for variable `declS`
pub const ID_VARIABLE_DECL_S: u32 = 0x000F;
/// The unique identifier for variable `import`
pub const ID_VARIABLE_IMPORT: u32 = 0x0010;
/// The unique identifier for variable `decl`
pub const ID_VARIABLE_DECL: u32 = 0x0011;
/// The unique identifier for variable `stmtS`
pub const ID_VARIABLE_STMT_S: u32 = 0x0012;
/// The unique identifier for variable `forkS`
pub const ID_VARIABLE_FORK_S: u32 = 0x0013;
/// The unique identifier for variable `for`
pub const ID_VARIABLE_FOR: u32 = 0x0014;
/// The unique identifier for variable `draw`
pub const ID_VARIABLE_DRAW: u32 = 0x0015;
/// The unique identifier for variable `return`
pub const ID_VARIABLE_RETURN: u32 = 0x0016;
/// The unique identifier for variable `funcDecl`
pub const ID_VARIABLE_FUNC_DECL: u32 = 0x0017;
/// The unique identifier for variable `assign`
pub const ID_VARIABLE_ASSIGN: u32 = 0x0018;
/// The unique identifier for variable `varDecl`
pub const ID_VARIABLE_VAR_DECL: u32 = 0x0019;
/// The unique identifier for variable `fork`
pub const ID_VARIABLE_FORK: u32 = 0x001A;
/// The unique identifier for variable `forkExpr`
pub const ID_VARIABLE_FORK_EXPR: u32 = 0x001B;
/// The unique identifier for variable `otherwise`
pub const ID_VARIABLE_OTHERWISE: u32 = 0x001C;
/// The unique identifier for variable `exprS`
pub const ID_VARIABLE_EXPR_S: u32 = 0x001D;
/// The unique identifier for variable `exprFunc`
pub const ID_VARIABLE_EXPR_FUNC: u32 = 0x001E;
/// The unique identifier for variable `expr`
pub const ID_VARIABLE_EXPR: u32 = 0x001F;
/// The unique identifier for variable `expr1`
pub const ID_VARIABLE_EXPR1: u32 = 0x0020;
/// The unique identifier for variable `expr2`
pub const ID_VARIABLE_EXPR2: u32 = 0x0021;
/// The unique identifier for variable `expr3`
pub const ID_VARIABLE_EXPR3: u32 = 0x0022;
/// The unique identifier for variable `expr4`
pub const ID_VARIABLE_EXPR4: u32 = 0x0023;
/// The unique identifier for variable `expr5`
pub const ID_VARIABLE_EXPR5: u32 = 0x0024;
/// The unique identifier for variable `expr6`
pub const ID_VARIABLE_EXPR6: u32 = 0x0025;
/// The unique identifier for variable `point`
pub const ID_VARIABLE_POINT: u32 = 0x0026;
/// The unique identifier for variable `FCall`
pub const ID_VARIABLE_FCALL: u32 = 0x0027;
/// The unique identifier for variable `member`
pub const ID_VARIABLE_MEMBER: u32 = 0x0028;
/// The unique identifier for variable `range`
pub const ID_VARIABLE_RANGE: u32 = 0x0029;
/// The unique identifier for variable `color`
pub const ID_VARIABLE_COLOR: u32 = 0x002A;
/// The unique identifier for variable `path`
pub const ID_VARIABLE_PATH: u32 = 0x002B;
/// The unique identifier for variable `polygon`
pub const ID_VARIABLE_POLYGON: u32 = 0x002C;
/// The unique identifier for variable `args`
pub const ID_VARIABLE_ARGS: u32 = 0x002D;
/// The unique identifier for variable `arg`
pub const ID_VARIABLE_ARG: u32 = 0x002E;
/// The unique identifier for variable `SCall`
pub const ID_VARIABLE_SCALL: u32 = 0x002F;
/// The unique identifier for variable `attrS`
pub const ID_VARIABLE_ATTR_S: u32 = 0x0030;
/// The unique identifier for variable `attr`
pub const ID_VARIABLE_ATTR: u32 = 0x0031;
/// The unique identifier for variable `arrayIdx`
pub const ID_VARIABLE_ARRAY_IDX: u32 = 0x0032;
/// The unique identifier for variable `array`
pub const ID_VARIABLE_ARRAY: u32 = 0x0033;
/// The unique identifier for variable `pos`
pub const ID_VARIABLE_POS: u32 = 0x0034;
/// The unique identifier for variable `manipulation`
pub const ID_VARIABLE_MANIPULATION: u32 = 0x0035;
/// The unique identifier for variable `place`
pub const ID_VARIABLE_PLACE: u32 = 0x0036;
/// The unique identifier for variable `scale`
pub const ID_VARIABLE_SCALE: u32 = 0x0037;
/// The unique identifier for variable `rotate`
pub const ID_VARIABLE_ROTATE: u32 = 0x0038;
/// The unique identifier for variable `params`
pub const ID_VARIABLE_PARAMS: u32 = 0x0039;
/// The unique identifier for variable `param`
pub const ID_VARIABLE_PARAM: u32 = 0x003A;
/// The unique identifier for variable `types`
pub const ID_VARIABLE_TYPES: u32 = 0x003B;
/// The unique identifier for variable `id`
pub const ID_VARIABLE_ID: u32 = 0x003C;


/// The collection of variables matched by this parser
/// The variables are in an order consistent with the automaton,
/// so that variable indices in the automaton can be used to retrieve the variables in this table
pub const VARIABLES: &[Symbol] = &[
    Symbol {
        id: 0x000E,
        name: "program"
    },
    Symbol {
        id: 0x000F,
        name: "declS"
    },
    Symbol {
        id: 0x0010,
        name: "import"
    },
    Symbol {
        id: 0x0011,
        name: "decl"
    },
    Symbol {
        id: 0x0012,
        name: "stmtS"
    },
    Symbol {
        id: 0x0013,
        name: "forkS"
    },
    Symbol {
        id: 0x0014,
        name: "for"
    },
    Symbol {
        id: 0x0015,
        name: "draw"
    },
    Symbol {
        id: 0x0016,
        name: "return"
    },
    Symbol {
        id: 0x0017,
        name: "funcDecl"
    },
    Symbol {
        id: 0x0018,
        name: "assign"
    },
    Symbol {
        id: 0x0019,
        name: "varDecl"
    },
    Symbol {
        id: 0x001A,
        name: "fork"
    },
    Symbol {
        id: 0x001B,
        name: "forkExpr"
    },
    Symbol {
        id: 0x001C,
        name: "otherwise"
    },
    Symbol {
        id: 0x001D,
        name: "exprS"
    },
    Symbol {
        id: 0x001E,
        name: "exprFunc"
    },
    Symbol {
        id: 0x001F,
        name: "expr"
    },
    Symbol {
        id: 0x0020,
        name: "expr1"
    },
    Symbol {
        id: 0x0021,
        name: "expr2"
    },
    Symbol {
        id: 0x0022,
        name: "expr3"
    },
    Symbol {
        id: 0x0023,
        name: "expr4"
    },
    Symbol {
        id: 0x0024,
        name: "expr5"
    },
    Symbol {
        id: 0x0025,
        name: "expr6"
    },
    Symbol {
        id: 0x0026,
        name: "point"
    },
    Symbol {
        id: 0x0027,
        name: "FCall"
    },
    Symbol {
        id: 0x0028,
        name: "member"
    },
    Symbol {
        id: 0x0029,
        name: "range"
    },
    Symbol {
        id: 0x002A,
        name: "color"
    },
    Symbol {
        id: 0x002B,
        name: "path"
    },
    Symbol {
        id: 0x002C,
        name: "polygon"
    },
    Symbol {
        id: 0x002D,
        name: "args"
    },
    Symbol {
        id: 0x002E,
        name: "arg"
    },
    Symbol {
        id: 0x002F,
        name: "SCall"
    },
    Symbol {
        id: 0x0030,
        name: "attrS"
    },
    Symbol {
        id: 0x0031,
        name: "attr"
    },
    Symbol {
        id: 0x0032,
        name: "arrayIdx"
    },
    Symbol {
        id: 0x0033,
        name: "array"
    },
    Symbol {
        id: 0x0034,
        name: "pos"
    },
    Symbol {
        id: 0x0035,
        name: "manipulation"
    },
    Symbol {
        id: 0x0036,
        name: "place"
    },
    Symbol {
        id: 0x0037,
        name: "scale"
    },
    Symbol {
        id: 0x0038,
        name: "rotate"
    },
    Symbol {
        id: 0x0039,
        name: "params"
    },
    Symbol {
        id: 0x003A,
        name: "param"
    },
    Symbol {
        id: 0x003B,
        name: "types"
    },
    Symbol {
        id: 0x003C,
        name: "id"
    },
    Symbol {
        id: 0x003E,
        name: "__V62"
    },
    Symbol {
        id: 0x0043,
        name: "__V67"
    },
    Symbol {
        id: 0x004F,
        name: "__V79"
    },
    Symbol {
        id: 0x0065,
        name: "__V101"
    },
    Symbol {
        id: 0x0068,
        name: "__V104"
    },
    Symbol {
        id: 0x006B,
        name: "__V107"
    },
    Symbol {
        id: 0x006E,
        name: "__V110"
    },
    Symbol {
        id: 0x006F,
        name: "__V111"
    },
    Symbol {
        id: 0x007B,
        name: "__V123"
    },
    Symbol {
        id: 0x0084,
        name: "__V132"
    },
    Symbol {
        id: 0x0085,
        name: "__VAxiom"
    }
];

/// The collection of virtuals matched by this parser
/// The virtuals are in an order consistent with the automaton,
/// so that virtual indices in the automaton can be used to retrieve the virtuals in this table
pub const VIRTUALS: &[Symbol] = &[

];

/// Parses the specified string with this parser
#[must_use]
pub fn parse_str(input: &str) -> ParseResult<'static, '_, 'static, AstImpl> {
    let text = Text::from_str(input);
    parse_text(text)
}

/// Parses the specified string with this parser
#[must_use]
pub fn parse_string(input: String) -> ParseResultAst {
    let text = Text::from_string(input);
    parse_text(text)
}

/// Parses the specified stream of UTF-8 with this parser
///
/// # Errors
///
/// Return an `std::io::Error` when reading the stream as UTF-8 fails
pub fn parse_utf8_stream(input: &mut dyn std::io::Read) -> Result<ParseResultAst, std::io::Error> {
    let text = Text::from_utf8_stream(input)?;
    Ok(parse_text(text))
}

/// Parses the specified text with this parser
fn parse_text<'t>(text: Text<'t>) -> ParseResult<'static, 't, 'static, AstImpl> {
    parse_text_with(text, TERMINALS, VARIABLES, VIRTUALS)
}

/// Parses the specified text with this parser
fn parse_text_with<'s, 't, 'a>(
    text: Text<'t>,
    terminals: &'a [Symbol<'s>],
    variables: &'a [Symbol<'s>],
    virtuals: &'a [Symbol<'s>],
) -> ParseResult<'s, 't, 'a, AstImpl> {
    let mut my_actions = |_index: usize, _head: Symbol, _body: &dyn SemanticBody| {};
    let mut result = ParseResult::<AstImpl>::new(terminals, variables, virtuals, text);
    {
        let data = result.get_parsing_data();
        let mut lexer = new_lexer(data.0, data.1);
        let automaton = LRkAutomaton::new(PARSER_AUTOMATON);
        let mut parser = LRkParser::new(&mut lexer, variables, virtuals, automaton, data.2, &mut my_actions);
        parser.parse();
    }
    result
}

/// Visitor interface
#[allow(unused_variables)]
pub trait Visitor {
    fn on_terminal_separator(&self, node: &AstNode) {}
    fn on_terminal_integer(&self, node: &AstNode) {}
    fn on_terminal_float(&self, node: &AstNode) {}
    fn on_terminal_identifier(&self, node: &AstNode) {}
    fn on_terminal_string(&self, node: &AstNode) {}
    fn on_terminal_boolean(&self, node: &AstNode) {}
    fn on_variable_program(&self, node: &AstNode) {}
    fn on_variable_decl_s(&self, node: &AstNode) {}
    fn on_variable_import(&self, node: &AstNode) {}
    fn on_variable_decl(&self, node: &AstNode) {}
    fn on_variable_stmt_s(&self, node: &AstNode) {}
    fn on_variable_fork_s(&self, node: &AstNode) {}
    fn on_variable_for(&self, node: &AstNode) {}
    fn on_variable_draw(&self, node: &AstNode) {}
    fn on_variable_return(&self, node: &AstNode) {}
    fn on_variable_func_decl(&self, node: &AstNode) {}
    fn on_variable_assign(&self, node: &AstNode) {}
    fn on_variable_var_decl(&self, node: &AstNode) {}
    fn on_variable_fork(&self, node: &AstNode) {}
    fn on_variable_fork_expr(&self, node: &AstNode) {}
    fn on_variable_otherwise(&self, node: &AstNode) {}
    fn on_variable_expr_s(&self, node: &AstNode) {}
    fn on_variable_expr_func(&self, node: &AstNode) {}
    fn on_variable_expr(&self, node: &AstNode) {}
    fn on_variable_expr1(&self, node: &AstNode) {}
    fn on_variable_expr2(&self, node: &AstNode) {}
    fn on_variable_expr3(&self, node: &AstNode) {}
    fn on_variable_expr4(&self, node: &AstNode) {}
    fn on_variable_expr5(&self, node: &AstNode) {}
    fn on_variable_expr6(&self, node: &AstNode) {}
    fn on_variable_point(&self, node: &AstNode) {}
    fn on_variable_fcall(&self, node: &AstNode) {}
    fn on_variable_member(&self, node: &AstNode) {}
    fn on_variable_range(&self, node: &AstNode) {}
    fn on_variable_color(&self, node: &AstNode) {}
    fn on_variable_path(&self, node: &AstNode) {}
    fn on_variable_polygon(&self, node: &AstNode) {}
    fn on_variable_args(&self, node: &AstNode) {}
    fn on_variable_arg(&self, node: &AstNode) {}
    fn on_variable_scall(&self, node: &AstNode) {}
    fn on_variable_attr_s(&self, node: &AstNode) {}
    fn on_variable_attr(&self, node: &AstNode) {}
    fn on_variable_array_idx(&self, node: &AstNode) {}
    fn on_variable_array(&self, node: &AstNode) {}
    fn on_variable_pos(&self, node: &AstNode) {}
    fn on_variable_manipulation(&self, node: &AstNode) {}
    fn on_variable_place(&self, node: &AstNode) {}
    fn on_variable_scale(&self, node: &AstNode) {}
    fn on_variable_rotate(&self, node: &AstNode) {}
    fn on_variable_params(&self, node: &AstNode) {}
    fn on_variable_param(&self, node: &AstNode) {}
    fn on_variable_types(&self, node: &AstNode) {}
    fn on_variable_id(&self, node: &AstNode) {}
}

/// Walk the AST of a result using a visitor
pub fn visit(result: &ParseResult<AstImpl>, visitor: &dyn Visitor) {
    let ast = result.get_ast();
    let root = ast.get_root();
    visit_ast_node(root, visitor);
}

/// Walk the sub-AST from the specified node using a visitor
pub fn visit_ast_node(node: AstNode, visitor: &dyn Visitor) {
    let children = node.children();
    for child in children.iter() {
        visit_ast_node(child, visitor);
    }
    match node.get_symbol().id {
        0x0006 => visitor.on_terminal_separator(&node),
        0x0008 => visitor.on_terminal_integer(&node),
        0x0009 => visitor.on_terminal_float(&node),
        0x000B => visitor.on_terminal_identifier(&node),
        0x000C => visitor.on_terminal_string(&node),
        0x000D => visitor.on_terminal_boolean(&node),
        0x000E => visitor.on_variable_program(&node),
        0x000F => visitor.on_variable_decl_s(&node),
        0x0010 => visitor.on_variable_import(&node),
        0x0011 => visitor.on_variable_decl(&node),
        0x0012 => visitor.on_variable_stmt_s(&node),
        0x0013 => visitor.on_variable_fork_s(&node),
        0x0014 => visitor.on_variable_for(&node),
        0x0015 => visitor.on_variable_draw(&node),
        0x0016 => visitor.on_variable_return(&node),
        0x0017 => visitor.on_variable_func_decl(&node),
        0x0018 => visitor.on_variable_assign(&node),
        0x0019 => visitor.on_variable_var_decl(&node),
        0x001A => visitor.on_variable_fork(&node),
        0x001B => visitor.on_variable_fork_expr(&node),
        0x001C => visitor.on_variable_otherwise(&node),
        0x001D => visitor.on_variable_expr_s(&node),
        0x001E => visitor.on_variable_expr_func(&node),
        0x001F => visitor.on_variable_expr(&node),
        0x0020 => visitor.on_variable_expr1(&node),
        0x0021 => visitor.on_variable_expr2(&node),
        0x0022 => visitor.on_variable_expr3(&node),
        0x0023 => visitor.on_variable_expr4(&node),
        0x0024 => visitor.on_variable_expr5(&node),
        0x0025 => visitor.on_variable_expr6(&node),
        0x0026 => visitor.on_variable_point(&node),
        0x0027 => visitor.on_variable_fcall(&node),
        0x0028 => visitor.on_variable_member(&node),
        0x0029 => visitor.on_variable_range(&node),
        0x002A => visitor.on_variable_color(&node),
        0x002B => visitor.on_variable_path(&node),
        0x002C => visitor.on_variable_polygon(&node),
        0x002D => visitor.on_variable_args(&node),
        0x002E => visitor.on_variable_arg(&node),
        0x002F => visitor.on_variable_scall(&node),
        0x0030 => visitor.on_variable_attr_s(&node),
        0x0031 => visitor.on_variable_attr(&node),
        0x0032 => visitor.on_variable_array_idx(&node),
        0x0033 => visitor.on_variable_array(&node),
        0x0034 => visitor.on_variable_pos(&node),
        0x0035 => visitor.on_variable_manipulation(&node),
        0x0036 => visitor.on_variable_place(&node),
        0x0037 => visitor.on_variable_scale(&node),
        0x0038 => visitor.on_variable_rotate(&node),
        0x0039 => visitor.on_variable_params(&node),
        0x003A => visitor.on_variable_param(&node),
        0x003B => visitor.on_variable_types(&node),
        0x003C => visitor.on_variable_id(&node),
        _ => ()
    };
}
