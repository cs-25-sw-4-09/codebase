grammar cfg
{

  options
  {
    Axiom = "program"; // the top variable for this grammar
    Separator = "SEPARATOR"; // the terminal that represent white space
  }
  terminals
  {
    WHITE_SPACE -> U+0020 | U+0009 | U+000B | U+000C | U+000A
                  | U+000D | U+0085 | U+2028 | U+2029 | U+0009;

    COMMENT_MULTI -> '/*' ( .* - (.* '*/' .*) ) '*/';
    COMMENT_SINGLE -> '//' [^\r\n]* ;
    SEPARATOR   -> WHITE_SPACE+ | COMMENT_MULTI | COMMENT_SINGLE;

    CONST       -> [0-9];
    INTEGER -> [1-9] CONST* | '0';

    FLOAT       -> INTEGER? '.' CONST+;
    LETTER      -> [A-Za-z];


    IDENTIFIER -> (LETTER | '_') (LETTER | CONST | '_')*;
    STRING -> '"'(LETTER | '\\' | '/' | CONST | '.')*'"';
    BOOLEAN -> 'true' | 'false';

  }

  rules
  {
    //Start place
    program -> declS 'begin'! stmtS;

    //Declarations
    declS -> (import | decl)*;
    import -> 'import'! IDENTIFIER STRING ';'!;
    decl -> IDENTIFIER ':'! types ('='! exprS)?';'!;

    //Statements
    stmtS -> (forkS | for | draw | return | funcDecl | assign | arrayAssign | varDecl)+;

    forkS -> 'fork'! '{'! fork^ '}'!;
    for -> 'for'! IDENTIFIER 'in'! exprS 'to'! exprS '{'! stmtS '}'! ;
    draw -> 'draw'! exprS ('at'! exprS)? ';'!;
    return -> 'return'! exprS ';'!;
    funcDecl -> IDENTIFIER '('! params? ')'! ':'! types '->'! '{'! stmtS '}'!;
    assign -> IDENTIFIER '='! exprS ';'!;
    varDecl -> IDENTIFIER ':'! types '='! exprS ';'!;
    arrayAssign -> IDENTIFIER '['! exprS ']'! '='!  exprS ';'!;    

    fork -> forkExpr+ otherwise?;
    forkExpr -> '('! expr? ')'! '->'! '{'! stmtS '}'!;
    otherwise -> '('! 'otherwise'! ')'! '->'! '{'! stmtS '}'!;

    //Expressions
    exprS -> (manipulation | expr | SCall | path | polygon)^;
    expr -> expr '||'^ expr1 | expr1^;
    expr1 -> expr1 '&&'^ expr2 | expr2^;
    expr2 -> expr3 ('==' | '<' | '>' | '>=' | '<=' | '!=')^ expr3 | expr3^;
    expr3 -> expr3 '+'^ expr4 | expr3 '-'^ expr4 | expr4^;
    expr4 -> expr4 '%'^ expr5 | expr4 '*'^ expr5 | expr4 '/'^ expr5 | expr5^;
    expr5 -> '-'^expr6 | '!'^expr6 | expr6^;
    expr6 -> '('! exprS^ ')'! | expr7^; 
    expr7 -> ( color | point | FCall | FLOAT | INTEGER | IDENTIFIER | member | array | BOOLEAN | arrayIdx)^;

    FCall -> IDENTIFIER '('! args? ')'!;

    member -> IDENTIFIER '.'! IDENTIFIER;
    point -> '('! expr ','! expr ')'!;
    color -> '('! (expr) ','! (expr) ','! (expr) ','! (expr)')'! ;
    path   -> (point | IDENTIFIER) (('--' | '~~')^ (point | IDENTIFIER))+;
    polygon -> exprS(('--*' | '~~*')^);

    args -> exprS (','! exprS)*;

    SCall -> (path | IDENTIFIER | polygon) '(|'! attrS '|)'!;
    attrS -> (attr (','! attr)*)? ;
    attr -> IDENTIFIER '='! exprS;

    arrayIdx -> IDENTIFIER ('['! exprS ']'!)+;
    array -> ('['! ((exprS (','! exprS)*))? ']'! | '[]'!);

    pos -> ('left' | 'right' | 'top' | 'bottom' | 'ontop') expr ('by'! point)?;
    manipulation -> place | scale | rotate;
    place -> 'place'! expr pos;
    scale -> 'scale'! expr 'by'! expr;
    rotate -> 'rotate'! expr 'by'! expr;

    params -> param (','! param)*;
    param -> IDENTIFIER ':'! types;

    //Types
    types -> ('int' | 'float' | 'point' | 'color'
    | 'shape' | 'path' | 'polygon' | 'bool' | 'int[]' | 'float[]' | 'point[]' | 'color[]'
    | 'shape[]' | 'path[]' | 'polygon[]' | 'bool[]')^;
  }
}
