import string "./dap-lib/digital-font/string.dap";
import box "./dap-lib/lines/filledSqaure.dap";
heap: int[] = [];

begin

// Helper functions
parent(i: int): int -> {return (i-1)/2;}
leftchild(i: int): int -> {return 2 * i + 1;}
rightchild(i: int): int -> { return 2 * i + 2; }
swap(heap: int[], i: int, j: int):int[] -> {
    temp: int = heap[i];
    heap[i] = heap[j];
    heap[j] = temp;
    return heap;
}

heapifyUp(i: int, heap: int[]): int[] -> {
    fork {
        (i == 0) -> {return heap;}
        (otherwise) -> {
            p: int = parent(i);
            fork {
                (heap[i] < heap[p]) -> {
                    heap = swap(heap, i, p);
                    return heapifyUp(p, heap);
                }
                (otherwise) -> {return heap;}
            }
        }
    }
}

heapifyDown(i: int, heap: int[]): int[] -> {
    l: int = leftchild(i);
    r: int = rightchild(i);
    smallest: int = i;

    fork {
        (l < heap.size && heap[l] < heap[smallest]) -> {smallest = l;}
    }

    fork {
        (r < heap.size && heap[r] < heap[smallest]) -> {smallest = r;}
    }

    fork {
        (smallest != i) -> {
            heap = swap(heap, i, smallest);
            return heapifyDown(smallest, heap);
        }
        (otherwise) -> {return heap;}
    }
}

insert(heap: int[], value: int): int[] -> {
    heap = push(heap, value);
    return heapifyUp(heap.size -1, heap);
}

popMin(heap: int[]): int[] -> {
    // if the heap size is 0 an runtime error will happen
    fork {
        (heap.size == 0) -> {x: int = 123;}
        (otherwise) -> {
            min: int = heap[0];
            heap[0] = heap[heap.size - 1];
            heap = remove(heap, heap.size - 1);
            heap = heapifyDown(0, heap);
            return heap;
        }
    }
}

peekMin(heap: int[]): int -> {
    return heap[0];
}

heapToString(heap: int[]): int[] -> {
    string: int[] = [91];
    for i in 0 to (heap.size) {
        fork {
            (i == heap.size -1) -> {string = push(string, heap[i]);}
            (otherwise) -> {
                string = push(string, heap[i]);
                string = push(string, 44);
            }
        }
        
    }
    return push(string,93);
}

heap = insert(heap,3);
heapShape: shape = string(|string = heapToString(heap)|);
heap = insert(heap, 7);
heapShape = place string(|string = heapToString(heap)|) bottom (0,-1) offset heapShape;
heap = insert(heap, 1);
heapShape = place string(|string = heapToString(heap)|) bottom (0,-1) offset heapShape;
heap = insert(heap, 9);
heapShape = place string(|string = heapToString(heap)|) bottom (0,-1) offset heapShape;
heap = insert(heap, 0);
heapShape = place string(|string = heapToString(heap)|) bottom (0,-1) offset heapShape;
heap = insert(heap, 5);
heapShape = place string(|string = heapToString(heap)|) bottom (0,-1) offset heapShape;
heap = insert(heap, 2);
heapShape = place string(|string = heapToString(heap)|) bottom (0,-1) offset heapShape;
heap = insert(heap, 8);
heapShape = place string(|string = heapToString(heap)|) bottom (0,-1) offset heapShape;
heap = insert(heap, 6);
heapShape = place string(|string = heapToString(heap)|) bottom (0,-1) offset heapShape;
heap = insert(heap, 4);
heapShape = place string(|string = heapToString(heap)|) bottom (0,-1) offset heapShape;


draw box(|baseShape = heapShape, fill = (0,255,0,255)|);