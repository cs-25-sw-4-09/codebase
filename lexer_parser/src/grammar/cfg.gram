grammar cfg
{

  options
  {
    Axiom = "program"; // the top variable for this grammar
    Separator = "SEPARATOR"; // the terminal that represent white space
  }
  terminals
  {
    WHITE_SPACE -> U+0020 | U+0009 | U+000B | U+000C | U+000A 
                  | U+000D | U+0085 | U+2028 | U+2029 | U+0009;
                  
    COMMENT_MULTI -> '/*' ( .* - (.* '*/' .*) ) '*/';
    COMMENT_SINGLE -> '//' [^\r\n]* ;
    SEPARATOR   -> WHITE_SPACE+ | COMMENT_MULTI | COMMENT_SINGLE;

    CONST       -> [0-9];
    INTEGER -> [1-9] CONST* | '0';
    
    FLOAT       -> INTEGER? '.' CONST+;
    LETTER      -> [A-Za-z];
    
     
    IDENTIFIER -> (LETTER | '_') (LETTER | CONST | '_')*;
    STRING -> '"'(LETTER | '\\' | '/' | CONST | '.')*'"';

  }
  
  rules
  {
    //Start place
    program -> declS 'begin' stmtS; 
   
    //Declarations
    declS -> (import | decl)*;
    import -> 'import' id STRING ';';
    decl -> id ':' types ';';

    //Statements
    stmtS -> stmt+;

    stmt -> ('fork' '{' forkS '}' | 'for' id 'in' exprS '{' stmtS '}' 
    | 'draw' exprS ('at' exprS)? ';' | id (':' types)? '=' exprS ';' 
    | 'return' exprS ';' | id '(' params? ')' ':' types '->' '{' stmtS '}');

    forkS -> fork+ otherwise?;
    fork -> '(' expr_func ')' '->' '{' stmtS '}'; 
    otherwise -> '(' 'otherwise' ')' '->' '{' stmtS '}';
    
    //Expressions
    exprS -> (manipulation | expr_func | SCall | color | path | range)^;
    expr_func -> (expr | FCall )^;
    expr -> expr '||'^ expr1 | expr1^;
    expr1 -> expr1 '&&'^ expr2 | expr2^;
    expr2 -> expr3 ('==' | '<' | '>' | '>=' | '<=')^ expr3 | expr3^;
    expr3 -> expr3 '+'^ expr4 | expr3 '-'^ expr4 | expr4^;
    expr4 -> expr4 '%'^ expr5 | expr4 '*'^ expr5 | expr4 '/'^ expr5 | expr5^; 
    expr5 -> '-'^expr6 | '!'^expr6 | expr6^;
    expr6 -> (parenthesis | FLOAT | INTEGER | id | properties | array | bool)^;
        
    parenthesis -> '(' (expr | (expr | FCall) ',' (expr | FCall)) ')';

    bool -> ('true' | 'false')^;

    properties -> id '.' id; 
    range -> expr_func ('..' | '..=') expr_func;
    color -> '(' (expr | FCall) ',' (expr | FCall) ',' (expr | FCall) ',' (expr | FCall)')' ;
    path   -> expr_func (('--' | '~~') expr_func)+ (('--' | '~~')'*')?;
    FCall -> id '(' args ')';
    args -> arg (',' arg)*; 
    arg -> exprS;

    SCall -> (path | id) '(|' attr '|)';
    attr -> id '=' exprS (',' attr^)?;
    array -> id? ('[' args ']')+;
    
    pos -> ('left' | 'right' | 'top' | 'bottom' | 'on') expr (id | parenthesis | FCall)?;
    manipulation -> 'place' expr_func pos | 'scale' expr_func 'by' expr_func 
    | 'rotate' expr_func 'by' expr_func;
    
    params -> param (',' param)*;
    param -> id ':' types;

    //Types
    types -> ('int' | 'float' | types'[]' | 'point' | 'color' 
    | 'shape' | 'path' | 'polygon' | 'bool')^;
    
    //Simple things
    id -> IDENTIFIER^; 
  }
}