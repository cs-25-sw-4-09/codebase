/*
 * WARNING: this file has been generated by
 * Hime Parser Generator 4.4.0
 */

using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using Hime.Redist;
using Hime.Redist.Parsers;

namespace Cfg
{
	/// <summary>
	/// Represents a parser
	/// </summary>
	[GeneratedCodeAttribute("Hime.SDK", "4.4.0")]
	internal class CfgParser : LRkParser
	{
		/// <summary>
		/// The automaton for this parser
		/// </summary>
		private static readonly LRkAutomaton commonAutomaton = LRkAutomaton.Find(typeof(CfgParser), "CfgParser.bin");
		/// <summary>
		/// Contains the constant IDs for the variables and virtuals in this parser
		/// </summary>
		[GeneratedCodeAttribute("Hime.SDK", "4.4.0")]
		public class ID
		{
			/// <summary>
			/// The unique identifier for variable program
			/// </summary>
			public const int VariableProgram = 0x000D;
			/// <summary>
			/// The unique identifier for variable declS
			/// </summary>
			public const int VariableDeclS = 0x000E;
			/// <summary>
			/// The unique identifier for variable import
			/// </summary>
			public const int VariableImport = 0x000F;
			/// <summary>
			/// The unique identifier for variable decl
			/// </summary>
			public const int VariableDecl = 0x0010;
			/// <summary>
			/// The unique identifier for variable stmtS
			/// </summary>
			public const int VariableStmtS = 0x0011;
			/// <summary>
			/// The unique identifier for variable forkS
			/// </summary>
			public const int VariableForkS = 0x0012;
			/// <summary>
			/// The unique identifier for variable for
			/// </summary>
			public const int VariableFor = 0x0013;
			/// <summary>
			/// The unique identifier for variable draw
			/// </summary>
			public const int VariableDraw = 0x0014;
			/// <summary>
			/// The unique identifier for variable return
			/// </summary>
			public const int VariableReturn = 0x0015;
			/// <summary>
			/// The unique identifier for variable funcDecl
			/// </summary>
			public const int VariableFuncDecl = 0x0016;
			/// <summary>
			/// The unique identifier for variable assign
			/// </summary>
			public const int VariableAssign = 0x0017;
			/// <summary>
			/// The unique identifier for variable varDecl
			/// </summary>
			public const int VariableVarDecl = 0x0018;
			/// <summary>
			/// The unique identifier for variable fork
			/// </summary>
			public const int VariableFork = 0x0019;
			/// <summary>
			/// The unique identifier for variable forkExpr
			/// </summary>
			public const int VariableForkExpr = 0x001A;
			/// <summary>
			/// The unique identifier for variable otherwise
			/// </summary>
			public const int VariableOtherwise = 0x001B;
			/// <summary>
			/// The unique identifier for variable exprS
			/// </summary>
			public const int VariableExprS = 0x001C;
			/// <summary>
			/// The unique identifier for variable exprFunc
			/// </summary>
			public const int VariableExprFunc = 0x001D;
			/// <summary>
			/// The unique identifier for variable expr
			/// </summary>
			public const int VariableExpr = 0x001E;
			/// <summary>
			/// The unique identifier for variable expr1
			/// </summary>
			public const int VariableExpr1 = 0x001F;
			/// <summary>
			/// The unique identifier for variable expr2
			/// </summary>
			public const int VariableExpr2 = 0x0020;
			/// <summary>
			/// The unique identifier for variable expr3
			/// </summary>
			public const int VariableExpr3 = 0x0021;
			/// <summary>
			/// The unique identifier for variable expr4
			/// </summary>
			public const int VariableExpr4 = 0x0022;
			/// <summary>
			/// The unique identifier for variable expr5
			/// </summary>
			public const int VariableExpr5 = 0x0023;
			/// <summary>
			/// The unique identifier for variable expr6
			/// </summary>
			public const int VariableExpr6 = 0x0024;
			/// <summary>
			/// The unique identifier for variable point
			/// </summary>
			public const int VariablePoint = 0x0025;
			/// <summary>
			/// The unique identifier for variable bool
			/// </summary>
			public const int VariableBool = 0x0026;
			/// <summary>
			/// The unique identifier for variable properties
			/// </summary>
			public const int VariableProperties = 0x0027;
			/// <summary>
			/// The unique identifier for variable range
			/// </summary>
			public const int VariableRange = 0x0028;
			/// <summary>
			/// The unique identifier for variable color
			/// </summary>
			public const int VariableColor = 0x0029;
			/// <summary>
			/// The unique identifier for variable path
			/// </summary>
			public const int VariablePath = 0x002A;
			/// <summary>
			/// The unique identifier for variable FCall
			/// </summary>
			public const int VariableFcall = 0x002B;
			/// <summary>
			/// The unique identifier for variable args
			/// </summary>
			public const int VariableArgs = 0x002C;
			/// <summary>
			/// The unique identifier for variable arg
			/// </summary>
			public const int VariableArg = 0x002D;
			/// <summary>
			/// The unique identifier for variable SCall
			/// </summary>
			public const int VariableScall = 0x002E;
			/// <summary>
			/// The unique identifier for variable attrS
			/// </summary>
			public const int VariableAttrS = 0x002F;
			/// <summary>
			/// The unique identifier for variable attr
			/// </summary>
			public const int VariableAttr = 0x0030;
			/// <summary>
			/// The unique identifier for variable arrayIdx
			/// </summary>
			public const int VariableArrayIdx = 0x0031;
			/// <summary>
			/// The unique identifier for variable array
			/// </summary>
			public const int VariableArray = 0x0032;
			/// <summary>
			/// The unique identifier for variable pos
			/// </summary>
			public const int VariablePos = 0x0033;
			/// <summary>
			/// The unique identifier for variable manipulation
			/// </summary>
			public const int VariableManipulation = 0x0034;
			/// <summary>
			/// The unique identifier for variable params
			/// </summary>
			public const int VariableParams = 0x0035;
			/// <summary>
			/// The unique identifier for variable param
			/// </summary>
			public const int VariableParam = 0x0036;
			/// <summary>
			/// The unique identifier for variable types
			/// </summary>
			public const int VariableTypes = 0x0037;
			/// <summary>
			/// The unique identifier for variable id
			/// </summary>
			public const int VariableId = 0x0038;
		}
		/// <summary>
		/// The collection of variables matched by this parser
		/// </summary>
		/// <remarks>
		/// The variables are in an order consistent with the automaton,
		/// so that variable indices in the automaton can be used to retrieve the variables in this table
		/// </remarks>
		private static readonly Symbol[] variables = {
			new Symbol(0x000D, "program"), 
			new Symbol(0x000E, "declS"), 
			new Symbol(0x000F, "import"), 
			new Symbol(0x0010, "decl"), 
			new Symbol(0x0011, "stmtS"), 
			new Symbol(0x0012, "forkS"), 
			new Symbol(0x0013, "for"), 
			new Symbol(0x0014, "draw"), 
			new Symbol(0x0015, "return"), 
			new Symbol(0x0016, "funcDecl"), 
			new Symbol(0x0017, "assign"), 
			new Symbol(0x0018, "varDecl"), 
			new Symbol(0x0019, "fork"), 
			new Symbol(0x001A, "forkExpr"), 
			new Symbol(0x001B, "otherwise"), 
			new Symbol(0x001C, "exprS"), 
			new Symbol(0x001D, "exprFunc"), 
			new Symbol(0x001E, "expr"), 
			new Symbol(0x001F, "expr1"), 
			new Symbol(0x0020, "expr2"), 
			new Symbol(0x0021, "expr3"), 
			new Symbol(0x0022, "expr4"), 
			new Symbol(0x0023, "expr5"), 
			new Symbol(0x0024, "expr6"), 
			new Symbol(0x0025, "point"), 
			new Symbol(0x0026, "bool"), 
			new Symbol(0x0027, "properties"), 
			new Symbol(0x0028, "range"), 
			new Symbol(0x0029, "color"), 
			new Symbol(0x002A, "path"), 
			new Symbol(0x002B, "FCall"), 
			new Symbol(0x002C, "args"), 
			new Symbol(0x002D, "arg"), 
			new Symbol(0x002E, "SCall"), 
			new Symbol(0x002F, "attrS"), 
			new Symbol(0x0030, "attr"), 
			new Symbol(0x0031, "arrayIdx"), 
			new Symbol(0x0032, "array"), 
			new Symbol(0x0033, "pos"), 
			new Symbol(0x0034, "manipulation"), 
			new Symbol(0x0035, "params"), 
			new Symbol(0x0036, "param"), 
			new Symbol(0x0037, "types"), 
			new Symbol(0x0038, "id"), 
			new Symbol(0x003A, "__V58"), 
			new Symbol(0x003E, "__V62"), 
			new Symbol(0x004B, "__V75"), 
			new Symbol(0x0062, "__V98"), 
			new Symbol(0x0063, "__V99"), 
			new Symbol(0x0066, "__V102"), 
			new Symbol(0x0069, "__V105"), 
			new Symbol(0x006A, "__V106"), 
			new Symbol(0x0074, "__V116"), 
			new Symbol(0x007E, "__V126"), 
			new Symbol(0x007F, "__VAxiom") };
		/// <summary>
		/// The collection of virtuals matched by this parser
		/// </summary>
		/// <remarks>
		/// The virtuals are in an order consistent with the automaton,
		/// so that virtual indices in the automaton can be used to retrieve the virtuals in this table
		/// </remarks>
		private static readonly Symbol[] virtuals = {
 };
		/// <summary>
		/// Initializes a new instance of the parser
		/// </summary>
		/// <param name="lexer">The input lexer</param>
		public CfgParser(CfgLexer lexer) : base (commonAutomaton, variables, virtuals, null, lexer) { }

		/// <summary>
		/// Visitor interface
		/// </summary>
		[GeneratedCodeAttribute("Hime.SDK", "4.4.0")]
		public class Visitor
		{
			public virtual void OnTerminalSeparator(ASTNode node) {}
			public virtual void OnTerminalInteger(ASTNode node) {}
			public virtual void OnTerminalFloat(ASTNode node) {}
			public virtual void OnTerminalIdentifier(ASTNode node) {}
			public virtual void OnTerminalString(ASTNode node) {}
			public virtual void OnVariableProgram(ASTNode node) {}
			public virtual void OnVariableDeclS(ASTNode node) {}
			public virtual void OnVariableImport(ASTNode node) {}
			public virtual void OnVariableDecl(ASTNode node) {}
			public virtual void OnVariableStmtS(ASTNode node) {}
			public virtual void OnVariableForkS(ASTNode node) {}
			public virtual void OnVariableFor(ASTNode node) {}
			public virtual void OnVariableDraw(ASTNode node) {}
			public virtual void OnVariableReturn(ASTNode node) {}
			public virtual void OnVariableFuncDecl(ASTNode node) {}
			public virtual void OnVariableAssign(ASTNode node) {}
			public virtual void OnVariableVarDecl(ASTNode node) {}
			public virtual void OnVariableFork(ASTNode node) {}
			public virtual void OnVariableForkExpr(ASTNode node) {}
			public virtual void OnVariableOtherwise(ASTNode node) {}
			public virtual void OnVariableExprS(ASTNode node) {}
			public virtual void OnVariableExprFunc(ASTNode node) {}
			public virtual void OnVariableExpr(ASTNode node) {}
			public virtual void OnVariableExpr1(ASTNode node) {}
			public virtual void OnVariableExpr2(ASTNode node) {}
			public virtual void OnVariableExpr3(ASTNode node) {}
			public virtual void OnVariableExpr4(ASTNode node) {}
			public virtual void OnVariableExpr5(ASTNode node) {}
			public virtual void OnVariableExpr6(ASTNode node) {}
			public virtual void OnVariablePoint(ASTNode node) {}
			public virtual void OnVariableBool(ASTNode node) {}
			public virtual void OnVariableProperties(ASTNode node) {}
			public virtual void OnVariableRange(ASTNode node) {}
			public virtual void OnVariableColor(ASTNode node) {}
			public virtual void OnVariablePath(ASTNode node) {}
			public virtual void OnVariableFcall(ASTNode node) {}
			public virtual void OnVariableArgs(ASTNode node) {}
			public virtual void OnVariableArg(ASTNode node) {}
			public virtual void OnVariableScall(ASTNode node) {}
			public virtual void OnVariableAttrS(ASTNode node) {}
			public virtual void OnVariableAttr(ASTNode node) {}
			public virtual void OnVariableArrayIdx(ASTNode node) {}
			public virtual void OnVariableArray(ASTNode node) {}
			public virtual void OnVariablePos(ASTNode node) {}
			public virtual void OnVariableManipulation(ASTNode node) {}
			public virtual void OnVariableParams(ASTNode node) {}
			public virtual void OnVariableParam(ASTNode node) {}
			public virtual void OnVariableTypes(ASTNode node) {}
			public virtual void OnVariableId(ASTNode node) {}
		}

		/// <summary>
		/// Walk the AST of a result using a visitor
		/// <param name="result">The parse result</param>
		/// <param name="visitor">The visitor to use</param>
		/// </summary>
		public static void Visit(ParseResult result, Visitor visitor)
		{
			VisitASTNode(result.Root, visitor);
		}

		/// <summary>
		/// Walk the sub-AST from the specified node using a visitor
		/// </summary>
		/// <param name="node">The AST node to start from</param>
		/// <param name="visitor">The visitor to use</param>
		public static void VisitASTNode(ASTNode node, Visitor visitor)
		{
			for (int i = 0; i < node.Children.Count; i++)
				VisitASTNode(node.Children[i], visitor);
			switch(node.Symbol.ID)
			{
				case 0x0006: visitor.OnTerminalSeparator(node); break;
				case 0x0008: visitor.OnTerminalInteger(node); break;
				case 0x0009: visitor.OnTerminalFloat(node); break;
				case 0x000B: visitor.OnTerminalIdentifier(node); break;
				case 0x000C: visitor.OnTerminalString(node); break;
				case 0x000D: visitor.OnVariableProgram(node); break;
				case 0x000E: visitor.OnVariableDeclS(node); break;
				case 0x000F: visitor.OnVariableImport(node); break;
				case 0x0010: visitor.OnVariableDecl(node); break;
				case 0x0011: visitor.OnVariableStmtS(node); break;
				case 0x0012: visitor.OnVariableForkS(node); break;
				case 0x0013: visitor.OnVariableFor(node); break;
				case 0x0014: visitor.OnVariableDraw(node); break;
				case 0x0015: visitor.OnVariableReturn(node); break;
				case 0x0016: visitor.OnVariableFuncDecl(node); break;
				case 0x0017: visitor.OnVariableAssign(node); break;
				case 0x0018: visitor.OnVariableVarDecl(node); break;
				case 0x0019: visitor.OnVariableFork(node); break;
				case 0x001A: visitor.OnVariableForkExpr(node); break;
				case 0x001B: visitor.OnVariableOtherwise(node); break;
				case 0x001C: visitor.OnVariableExprS(node); break;
				case 0x001D: visitor.OnVariableExprFunc(node); break;
				case 0x001E: visitor.OnVariableExpr(node); break;
				case 0x001F: visitor.OnVariableExpr1(node); break;
				case 0x0020: visitor.OnVariableExpr2(node); break;
				case 0x0021: visitor.OnVariableExpr3(node); break;
				case 0x0022: visitor.OnVariableExpr4(node); break;
				case 0x0023: visitor.OnVariableExpr5(node); break;
				case 0x0024: visitor.OnVariableExpr6(node); break;
				case 0x0025: visitor.OnVariablePoint(node); break;
				case 0x0026: visitor.OnVariableBool(node); break;
				case 0x0027: visitor.OnVariableProperties(node); break;
				case 0x0028: visitor.OnVariableRange(node); break;
				case 0x0029: visitor.OnVariableColor(node); break;
				case 0x002A: visitor.OnVariablePath(node); break;
				case 0x002B: visitor.OnVariableFcall(node); break;
				case 0x002C: visitor.OnVariableArgs(node); break;
				case 0x002D: visitor.OnVariableArg(node); break;
				case 0x002E: visitor.OnVariableScall(node); break;
				case 0x002F: visitor.OnVariableAttrS(node); break;
				case 0x0030: visitor.OnVariableAttr(node); break;
				case 0x0031: visitor.OnVariableArrayIdx(node); break;
				case 0x0032: visitor.OnVariableArray(node); break;
				case 0x0033: visitor.OnVariablePos(node); break;
				case 0x0034: visitor.OnVariableManipulation(node); break;
				case 0x0035: visitor.OnVariableParams(node); break;
				case 0x0036: visitor.OnVariableParam(node); break;
				case 0x0037: visitor.OnVariableTypes(node); break;
				case 0x0038: visitor.OnVariableId(node); break;
			}
		}
	}
}
